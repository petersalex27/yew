yew program = [ header ], [ body ], [ footer ] ; 
header = [ meta ], [ tail ] ;
  meta = { env | embeds } ;
		env = annotation, { new line, annotation } ;
		embeds = "--\h@\h*embed\h*", string, string, new line, embed body, new line, end embed ;
			end embed = "--\h*@\h*end\h*embed)", string, new line, { new line } ;
			embed body = "(?!--\h*@\h*end\h*embed).*" ;
	tail = ([ module ], [ imports ]) | ([ imports ], [ module ]) ;
		module = "module", lower ident ;
		imports = { import } ;
		import = import package | import package group
		import package = "import", package ident ;
		import package group = "import", open paren, [ package sequence ], close paren ;
		package sequence = package ident, { some new lines, package ident } ;
body = { new line }, { main elem } ;
	main elem = body elem | mutual body ;
	mutual body = keyword mutual, ( body elem | body elem group ) ;
	body elem = def | spec def | spec inst | type def | type alias | typing | annotation ;
	body elem group = open paren, body elem, { new line, body elem }, close paren ;
	type def = name, keyword colon, type, keyword where, type def body, [ keyword derives, derives body ] ;
		type def body = type def elem | type def elem group ;
		type def elem = typing | "impossible" ;
		type def elem group = 
				( open paren, typing, { new line, typing }, close paren )
				| ( open paren, "impossible", close paren ) ;
		derives body = derives elem | derives elem group ;
			derives elem = spec ident ;
			derives elem group = open paren, spec ident, { keyword comma, spec ident }, keyword comma, close paren ;
	type alias = keyword alias, type def ;
	annotation = { new line }, "--", "@", ident, "[^\n]" ;
	spec def = [ doc annotation ], keyword spec, spec typing, keyword where, spec body ;
		spec body = spec member | spec member group ;
		spec member = def | typing ;
		spec member group = open paren, spec member, { new line, spec member }, close paren ;
		spec typing = spec ident, keyword colon, type ;
	typing = name, keyword colon, type ;
	explicit typing = name, keyword colon, explicit type ;
	explicit type = 
			pattern
			| ( opem paren, explicit typing, close paren )
			| ( open paren, explicit type, close paren ) (* enclosed type, e.g., '(a List 3)' *)
			| ( explicit type, "->", explicit type ) (* function type, e.g., 'a -> b' *)
			| ( open paren, explicit type, keyword comma, explicit type, { keyword comma,  explicit type }, close paren ) ; (*tuple type, e.g., '(a, b)' *)
	type =
			pattern (* a type, e.g., 'MyType a' *)
			| implicit type (* implicit argument's type *)
			| ( open paren, [ multiplicity ], typing, close paren )
			| forall type (* forall type, e.g., 'forall a b . a -> b' *)
			| ( open paren, type, close paren ) (* enclosed type, e.g., '(a, b)' *)
			| ( type,  "->", type )
			| ( open paren, type, keyword comma, type, { keyword comma, type }, close paren ) ;
		(* implicit argument's type, e.g., '{x : B a}'*)
		implicit type = open brace, ( ( ( [ mutltiplicity ] typing ) | explicit type ), [ keyword colon equal, expression ] ), close brace ;
		forall type = "forall", ( ( open paren, ident, { new line, ident }, close paren ) | ( ident, { ident } ) ), keyword dot, type ;
	spec inst = upper ident, name, where keyword, spec inst body ;
		spec inst body = spec inst member | spec inst member group ;
		spec inst member = def ;
		spec inst member group = open paren, spec inst member, { new line, spec inst member }, close paren ;
	(* basically, for now, this is just an application pattern that contains at least one 'name' *)
	name app pattern = { pattern }, name, { pattern } ;
	def = [ doc annotation ], name app pattern, ( def tail group | def tail ) ;
		def tail group = open paren,  def tail, close paren ;
		def tail = ( with clause | assignment ), [ where clause ] ;
			where clause = { new line }, "where", where body ;
			where body = main elem | ( open paren, main elem, { new line, main elem }, close paren ) ;
			where body group = open paren, main elem, { new line, main elem }, close paren ;
			with clause = keyword with, expression, keyword of, with arms ;
				with arms = ( open paren, some with clause arms, close paren ) | with clause arm ;
				some with clause arms = with clause arm, { with clause arm } ;
				with clause arm = [ lhs, keyword bar ], pattern, ( ( keyword equal, expression ) | with clause ) ;
					lhs = name app pattern | ( open paren, name app pattern, close paren ) | "_" ;
			assignment = keyword equal, expression ;
	pattern = 
			literal value 
			| "_"
			| name 
			| pattern list 
			| ( pattern, pattern ) 
			| ( open paren, pattern, close paren )
			| ( open paren, pattern, keyword comma, pattern, { keyword comma, pattern }, close paren ) ; 
		pattern list = open bracket, pattern, { keyword comma, pattern }, keyword comma, close bracket ;
	expression = 
			pattern 
			| lambda abstraction 
			| let expression 
			| case expression 
			| expression list 
			| ( expression, expression )
			| ( open paren, expression, close paren ) ;
		expression list = open bracket, expression, { keyword comma, expression }, keyword comma, close bracket ;
		lambda abstraction = backslash, lambda binders, keyword thick arrow, expression ;
			lambda binders = lambda binder, { keyword comma, lambda binder }, [ keyword comma ] ;
			lambda binder = ident | typed binder ;
			typed binder = open paren, typed ident, close paren ;
		typed ident = ident, keyword colon, type ;
		let expression = keyword let, ( binding group | binding assignment ), keyword in, expression ;
			binding group = open paren, binding assignment, { new line, binding assignment }, close paren ;
			binding assignment = ( 
					( ident, { new line }, ( "=" | ":=" ) ) 
					| ( typed ident, { new line }, ":=" ) 
				), { new line }, expression ;
		case expression = keyword case, expression, keyword of, case arms ;
			case arms = case arm | ( open paren, case arm group, close paren ) ;
			case arm group = case arm, { new line, case arm }, { new line } ;
			case arm = pattern, keyword equal, expression ;

footer = [ annotation,  { new line, annotation } ], end of file ;

keyword let = { new line }, "let", { new line } ;
keyword in = { new line }, "in", { new line } ;
keyword spec = { new line }, "spec", { new line } ;
keyword case = { new line } , "case", { new line } ;
keyword with = { new line } , "with", { new line } ;
keyword mutual = { new line }, "mutual", { new line } ;
keyword alias = { new line }, "alias", { new line } ;
keyword derives = { new line }, "derives", { new line } ;
keyword of = { new line }, "of", { new line } ;
keyword dot = { new line }, ".", { new line } ;
keyword bar = { new line }, "|", { new line} ;
keyword comma = { new line }, ",", { new line } ;
keyword equal = { new line }, "=", { new line } ;
keyword colon equal = { new line }, ":=", { new line } ;
keyword arrow = { new line }, "->", { new line } ;
keyword thick arrow = { new line }, "=>", { new line } ;
keyword colon = { new line }, ":", { new line } ;

lower ident = "[a-z][a-zA-Z0-9']*" ;
upper ident = "[A-Z][a-zA-Z0-9']*" ;
spec ident = ( upper ident | symbol | ( "(", upper ident, ")" ) | ( "(", symbol, ")", ) ) ;
open paren = "(", { new line } ;
close paren = { new line }, ")" ;
open bracket = "[", { new line } ;
close bracket = { new line }, "]" ;
open brace = "{", { new line } ;
close brace = { new line }, "}" ;
ident = lower ident | upper ident ;
symbol = "[-/*=<>!@#$%^&\\|~?+\|:;,.]+" ;
prefixed name = ident | symbol ;
infixed name = "(", ( prefixed name ), ")" ;
name = prefixed name | infixed name ;
package ident = lower ident, { "/", lower ident }, [ ".", name ] ;
new line = ? ASCII character 0xA ? ;
end of file = ? EOF ? ;
comment = "--[^\n]*" ;
comments = [ comment, { new line, comment } ] ;
doc annotation = "@doc\h*", new line, comments ;
backslash = "\\" ;

(* one or more/some/at least one new line(s) *)
some new lines = new line, { new line } ;

literal value = string | integer | float | char ;
string = raw string | escapable string ;
raw string = "`", "[^`]*", "`" ;
escapable string = "\"", { "\\[afnvtbr\\\"]" | "[^\n]" }, "\"" ;
integer = "[0-9]+(_[0-9]+)*" ;
float = "([0-9]+(_[0-9]+)*)?(\.[0-9]+(_[0-9]+)*)([eE][\+-][0-9]+(_[0-9]+)*)?" ;
char = "'", { "\\[afnvtbr\\']" | "[^\n]" }, "'" ;