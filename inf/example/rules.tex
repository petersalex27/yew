\documentclass[letterpaper]{article}

\usepackage{bussproofs}
\usepackage{syntax}

\begin{document}

  \newcommand{\Inst}{\textrm{Inst}}
  \newcommand{\Gen}{\textrm{Gen}}
  \newcommand{\Unify}{\textrm{Unify}}

  \section*{Definitions}
  \hrule

  %===============================================================================
  % Syntax of Terms
  %===============================================================================

  \section*{Syntax of Terms}

  \vspace*{10pt}
  \subsection*{Expressions}
  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <expression $e$> ::= $x$
    \alt $C$
    \alt $(e_i \textrm{ } e_j)$
    \alt $(\lambda x . e)$
    \alt $\textrm{let }x = e_i\textrm{ in }e_j$
  \end{grammar}

  \subsection*{Patterns\footnote{Some special cases exist, but these are just sugar; e.g., $x + 2$ may be used instead of $(Succ\textrm{ }(Succ\textrm{ }x))$}}
  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <pattern $p$> ::= $x$
    \alt $C$
    \alt $(p_i \textrm{ } p_j)$
  \end{grammar}

  \subsection*{Monotypes\footnote{Again, some special cases exist, but these are just sugar; e.g., $t_0 \rightarrow t_1$ may be used instead of $((\rightarrow\textrm{ }t_0)\textrm{ }t_1)$}}
  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <monotype $t$> ::= $v$
    \alt $C$
    \alt $(t_i \textrm{ } t_j)$
    \alt $(t; \textrm{ } p)$
  \end{grammar}

  \subsection*{Dependent Types}
  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <dependent-type $\delta$> ::= $t$
    \alt $\textrm{mapval }(x_0: t_0)\textrm{ }(x_1: t_1)\textrm{ }..\textrm{ }(x_i: t_i)\textrm{ }.\textrm{ }t_j$
  \end{grammar}

  \subsection*{Polytypes}
  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <polytype $\sigma$> ::= $\delta$
    \alt $\textrm{forall }v_0\textrm{ }v_1\textrm{ }..\textrm{ }v_i\textrm{ }.\textrm{ }\delta$
  \end{grammar}

  \newpage

  %===============================================================================
  % Syntax of Rules
  %===============================================================================

  \section*{Syntax of Rules}

  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <predicate> ::= $x: t\in\Gamma$
      \alt $Inst_d(\delta)=t$
      \alt $Inst_p(\sigma)=t$
      \alt $v=newvar$
      \alt $t_0=t_1$
  \end{grammar}

  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <judgement> ::= $e: \sigma$
      \alt $x: Gen(t)$
  \end{grammar}

  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <premise> ::= <predicate>
      \alt <judgement>
  \end{grammar}

  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <conclusion> ::= <judgement>
  \end{grammar}

  \begin{grammar}
    \renewcommand{\syntleft}{}
    \renewcommand{\syntright}{}
    <rule> ::= \begin{minipage}{82pt}
      \begin{prooftree}
        \AxiomC{premise}
        \RightLabel{[Rule]}
        \UnaryInfC{conclusion}
      \end{prooftree}
    \end{minipage}
  \end{grammar}
  
  \newpage

  %===============================================================================
  % Axioms
  %===============================================================================


  \newcommand{\VarRule}[3]{
    \RightLabel{[Var]}
    \BinaryInfC{$#1#2 : #3$}%
  }
  \newcommand{\Var}[2]{\VarRule{}{#1}{#2}}

  \newcommand{\AppRule}[4]{
    \RightLabel{[App]}
    \QuaternaryInfC{$#1(#2\ #3) : #4$}%
  }
  \newcommand{\App}[3]{\AppRule{}{#1}{#2}{#3}}

  \newcommand{\AbsRule}[5]{
    \RightLabel{[Abs]}
    \BinaryInfC{$#1(\lambda#2.#3) : #4\rightarrow#5$}%
  }
  \newcommand{\Abs}[4]{\AbsRule{}{#1}{#2}{#3}{#4}}

  \newcommand{\LetRule}[5]{
    \RightLabel{[Let]}
    \BinaryInfC{$#1\textrm{let}\ #2 = #3\ \textrm{in}\ #4 : #5$}%
  }
  \newcommand{\Let}[4]{\LetRule{}{#1}{#2}{#3}{#4}}

  \newcommand{\RecRule}[4]{
    \RightLabel{[Rec]}
    \BinaryInfC{$#1\textrm{rec}\ #2\ \textrm{in}\ #3 : #4$}%
  }
  \newcommand{\Rec}[3]{\LetRule{}{#1}{#2}{#3}}

  \section*{Rules}
  \hrule

  \vspace*{10pt}

  % Var rule
  \begin{prooftree}
    \def\fCenter{\ \vdash\ }
    \AxiomC{$x: \sigma \in \Gamma$}
    \AxiomC{$t=\Inst(\sigma)$}
    \VarRule{\Gamma\fCenter}{x}{t}
  \end{prooftree}

  % App rule
  \begin{prooftree}
    \def\fCenter{\ \vdash\ }
    \AxiomC{$\Gamma \fCenter e_0: t_0$}
    \AxiomC{$\Gamma \fCenter e_1: t_1$}
    \AxiomC{$t_2 = newvar$}
    \AxiomC{$\Unify(t_0,\ t_1 \rightarrow t_2)$}
    \AppRule{\Gamma\fCenter}{e_0}{e_1}{t_2}
  \end{prooftree}

  % Abs rule
  \begin{prooftree}
    \def\fCenter{\ \vdash\ }
    \AxiomC{$t_0 = newvar$}
    \AxiomC{$\Gamma, x: t_0 \fCenter e_0: t_1$}
    \AbsRule{\Gamma\fCenter}{x}{e_0}{t_0}{t_1}
  \end{prooftree}

  % Let rule
  \begin{prooftree}
    \def\fCenter{\ \vdash\ }
    \AxiomC{$\Gamma \fCenter e_0: t_0$}
    \AxiomC{$\Gamma, x: Gen(t_0) \fCenter e_1: t_1$}
    \LetRule{\Gamma\fCenter}{x}{e_0}{e_1}{t_1}
  \end{prooftree}

  % Rec rule
  \begin{prooftree}
    \def\fCenter{\ \vdash\ }
    \AxiomC{$\Gamma,\Gamma^\prime \fCenter e_1: t_1 \ ...\ \Gamma,\Gamma^\prime \fCenter e_n: t_n$}
    \AxiomC{$\Gamma,\Gamma^{\prime\prime} \fCenter e_0: t_0$}
    \RecRule{\Gamma\fCenter}{v_1=e_1\ \textrm{and}\ ...\ \textrm{and}\ v_n=e_n}{e_0}{t_0}
  \end{prooftree}

  % Export rule
  \begin{prooftree}
    \def\fCenter{\ \vdash\ }
    \AxiomC{$\Gamma \fCenter e_1: t_1 \ ...\ \Gamma,\Gamma^\prime \fCenter e_n: t_n$}
    \AxiomC{$\Gamma,\Gamma^{\prime\prime} \fCenter e_0: t_0$}
    \RecRule{\Gamma\fCenter}{v_1=e_1\ \textrm{and}\ ...\ \textrm{and}\ v_n=e_n}{e_0}{t_0}
  \end{prooftree}

  \newpage

  \section*{Example}
  \newcommand{\Succ}[1]{(\textrm{Succ}\ #1)}
  \newcommand{\Uint}{\textrm{Uint}}

  Let $\Uint = \{0:\Uint, \Succ{n}:\Uint\}$

  \noindent
  Let $\textrm{Array} = \{[]: [a; 0], (::):a\rightarrow[a;n]\rightarrow[a;\Succ{n}]\}$
  
  \noindent
  Let $\Gamma = \{tail: [a;\Succ{n}]\rightarrow[a;n]\}\cup\Uint\cup\textrm{Array}$
  
  \noindent
  Show $\Gamma\ \vdash\ tail\ (0::(0::[])): [\Uint; \Succ{0}]$

  \noindent
  \break
  To do this, we will first prove the following lemma:
  \[\Gamma\ \vdash\ 0::(0::[]): [\Uint; \Succ{\Succ{0}}]\]

  \begin{prooftree}
    \def\fCenter{\ \vdash\ }
    \AxiomC{$(::):a\rightarrow[a;n]\rightarrow[a;\Succ{n}]$}
    \AxiomC{$0:\Uint$}
    \AxiomC{$v_0=newvar$}
    \AxiomC{$a\rightarrow[a;n]\rightarrow[a;\Succ{n}]=\Uint\rightarrow v_0$}
    \App{(::)}{0}{v_0}
    \RightLabel{[Id]}
    \UnaryInfC{$v_0=[a;n]\rightarrow[a;\Succ{n}]$}
    \RightLabel{}
  \end{prooftree}

  \begin{prooftree}
    \def\fCenter{\ \vdash\ }

    \AxiomC{$[tail: \forall a.\prod_{n:\Uint}.[a;\Succ{n}]\rightarrow[a;n]]^1$}
    \AxiomC{$[v;\Succ{x}]\rightarrow[v;x] = \Inst(\forall a.\prod_{n:\Uint}.[a;\Succ{n}]\rightarrow[a;n])$}
    \Var{tail}{[v; \Succ{x}]\rightarrow[v;x]}

    %\AxiomC{}
  \end{prooftree}
\end{document}